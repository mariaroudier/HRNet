var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  Pagination: () => Pagination,
  getEndIndex: () => getEndIndex,
  getNextEnabled: () => getNextEnabled,
  getPaginationMeta: () => getPaginationMeta,
  getPreviousEnabled: () => getPreviousEnabled,
  getStartIndex: () => getStartIndex,
  getTotalPages: () => getTotalPages,
  limitPageBounds: () => limitPageBounds,
  usePagination: () => usePagination
});

// src/getPaginationMeta.ts
var getPreviousEnabled = (currentPage) => currentPage > 0;
var getNextEnabled = (currentPage, totalPages) => currentPage + 1 < totalPages;
var getTotalPages = (totalItems, pageSize) => Math.ceil(totalItems / pageSize);
var getStartIndex = (pageSize, currentPage) => pageSize * currentPage;
var getEndIndex = (pageSize, currentPage, totalItems) => {
  const lastPageEndIndex = pageSize * (currentPage + 1);
  if (lastPageEndIndex > totalItems) {
    return totalItems - 1;
  }
  return lastPageEndIndex - 1;
};
var limitPageBounds = (totalItems, pageSize) => (page) => Math.min(Math.max(page, 0), getTotalPages(totalItems, pageSize) - 1);
var getPaginationMeta = ({
  totalItems,
  pageSize,
  currentPage
}) => {
  const totalPages = getTotalPages(totalItems, pageSize);
  return {
    totalPages,
    startIndex: getStartIndex(pageSize, currentPage),
    endIndex: getEndIndex(pageSize, currentPage, totalItems),
    previousEnabled: getPreviousEnabled(currentPage),
    nextEnabled: getNextEnabled(currentPage, totalPages)
  };
};

// src/usePagination.ts
var import_react = __toModule(require("react"));

// src/paginationStateReducer.ts
var getCurrentPageReducer = (rootState) => function currentPageReducer(state, action) {
  switch (action.type) {
    case "SET_PAGE":
      return limitPageBounds(rootState.totalItems, rootState.pageSize)(action.page);
    case "NEXT_PAGE":
      return limitPageBounds(rootState.totalItems, rootState.pageSize)(state + 1);
    case "PREVIOUS_PAGE":
      return limitPageBounds(rootState.totalItems, rootState.pageSize)(state - 1);
    case "SET_PAGESIZE":
      return limitPageBounds(rootState.totalItems, action.pageSize)(action.nextPage ?? state);
    case "SET_TOTALITEMS":
      return limitPageBounds(action.totalItems, rootState.pageSize)(action.nextPage ?? state);
    default:
      return state;
  }
};
function totalItemsReducer(state, action) {
  switch (action.type) {
    case "SET_TOTALITEMS":
      return action.totalItems;
    default:
      return state;
  }
}
function pageSizeReducer(state, action) {
  switch (action.type) {
    case "SET_PAGESIZE":
      return action.pageSize;
    default:
      return state;
  }
}
function paginationStateReducer(state, action) {
  return {
    currentPage: getCurrentPageReducer(state)(state.currentPage, action),
    totalItems: totalItemsReducer(state.totalItems, action),
    pageSize: pageSizeReducer(state.pageSize, action)
  };
}

// src/usePagination.ts
function usePagination({
  totalItems = 0,
  initialPage = 0,
  initialPageSize = 0
} = {}) {
  const initialState = {
    totalItems,
    pageSize: initialPageSize,
    currentPage: initialPage
  };
  const [paginationState, dispatch] = (0, import_react.useReducer)(paginationStateReducer, initialState);
  const totalItemsRef = (0, import_react.useRef)(totalItems);
  totalItemsRef.current = totalItems;
  (0, import_react.useEffect)(() => {
    return () => {
      if (typeof totalItemsRef.current !== "number" || totalItems === totalItemsRef.current) {
        return;
      }
      dispatch({ type: "SET_TOTALITEMS", totalItems: totalItemsRef.current });
    };
  }, [totalItems]);
  return {
    ...paginationState,
    ...(0, import_react.useMemo)(() => getPaginationMeta(paginationState), [paginationState]),
    setPage: (0, import_react.useCallback)((page) => {
      dispatch({
        type: "SET_PAGE",
        page
      });
    }, []),
    setNextPage: (0, import_react.useCallback)(() => {
      dispatch({ type: "NEXT_PAGE" });
    }, []),
    setPreviousPage: (0, import_react.useCallback)(() => {
      dispatch({ type: "PREVIOUS_PAGE" });
    }, []),
    setPageSize: (0, import_react.useCallback)((pageSize, nextPage = 0) => {
      dispatch({ type: "SET_PAGESIZE", pageSize, nextPage });
    }, [])
  };
}

// src/Pagination.tsx
function Pagination({
  children,
  totalItems = 0,
  initialPage = 0,
  initialPageSize
}) {
  return children(usePagination({ totalItems, initialPage, initialPageSize }));
}
Pagination.displayName = "Pagination";
//# sourceMappingURL=react-use-pagination.js.map
